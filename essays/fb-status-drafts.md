# Q1 2016 Facebook Status Drafts

I'm 'into' politics again for the first time since 2004.

No one beyond your friends will ever like you or pay attention to you.  It is
just what you are.  There is always some fact of reality that can wear you down 
until you consider yourself wiser, for not wanting it any more.

We should burn all of the mountains and use the energy to power computers.

Next door, they seem to be digging a basement by hand.  On the first floor,
there's a nice apartment.  On the second and third floors, there's a coffee
packaging operation.  On the fourth floor, there's a mysterious silent digital
agency.  We share the fifth floor with a lingerie company.  There's a nice
apartment on the sixth floor.  I haven't tried to access the roof.  

What makes writing "seductive"?  By seductive writing I mean writing that you
want to keep reading, and also writing that you think about after you stop
reading.  Essentially, writing that you want.  Here are some observations:

1) Two key aspects of seductive writing are the creation of tension, and
effectively embodying the reader within the story.  Tension doesn't necessarily
have to seem "tense".  The tension I'm referring to is the tension that compels
you to wake up in the morning and continue living your life.  There are certain
things that pull you forward.  You desire the next thing.  

Embodiment is a big part of making tension work.  If the reader can feel
themselves in the story, it's a lot easier to create tension.  The reader is
going to feel the natural tension of an unexplored part of an environment or
relationship.

2) Writing can always fall flat on its face.  Seductive writing is very temporal
and subjective.  Not much is universally seductive.  Seductive writing can be
bad, or it can be good.

Many people have asked me what my secret is.  My secret is that I get pumped up
for *everything* I do.  In 2016, with a decent stack of genetics, environment,
and consistent effort, it is possible to be happy virtually all of the time.  If
you build your life on top of robust systems like Soylent, Adderall, TalkSpace,
SoulCycle, ReactJS, K******e, GitHub, and Harvest, almost nothing can ruin your
life, except for a few thorny edge cases.  But those are what make life
beautiful :). 

Please enjoy the pain which is unable to avoid. 
As the dog equally studies, the gentleman equally plays. 
If you nap now, you will interpret a dream, but if 
you wake, you will realize it. 
Now drips the saliva, will become tomorrow the tear.
Time passes.

When I ran away from home and my dad had to fly to North Dakota to retrieve me
from a juvenile detention center, he brought me swim trunks, anticipating that
we'd probably have to stay at a hotel.

A famous artist convinced my middle school art teacher to help him with with an
elaborate art project, but refused to give the teacher a little sketch after,
because "it would devalue [the famous artist's] work".

Coors light and keystone light are the exact same beer, just with different
branding.

A child just lost their favorite stuffed animal at a gas station, the family
drove away, leaving it sitting in dirty slush.


Translating things that Series A tech recruiters say:

- "We've transitioned a lot of our site to React" -> "We are trying to manage the
inherent complexity of our views by telling the junior developer to add a new
framework"

- "We have a microservice architecture" -> "No one can agree on anything, so we
give each developer their own ec2 box"

- "Data warehouse" -> "PostgreSQL database"

- "We do don't the typical whiteboard coding interview process" -> "First, you're
going to spend three hours on a homework assignment, and then you will do a
graph search coding problem on a whiteboard in person"

- "This is a really unique opportunity" -> "Most likely, you're going to waste
your time and also get screwed in terms of compensation"

- "We don't care how you get things done, we're really results oriented here" ->
"We need you to sit in our office every day, and sign a contract
devoting the next year of your life to the company"

- "We offer a really good value proposition to our customers" -> "We are mostly
useless in real-world terms"

The "show-don't-tell" school of writing teaches that you should use an
incredibly low-bandwidth channel to communicate images, sounds, smells, and
motions.  It's a futile attempt to increase the immediacy of prose by using the
techniques of film and art.  

Consider that the amount of actionable facts contained in an hour-long
documentary is roughly equivalent to the contents of an essay that you could
read in less than ten minutes.  The immediacy of writing lies in the highly
concise, memorable, and sharable nature of text.

In the past year I think I have undergone a shift from a mode of "becoming" to a
mode of "being".  As a child and young adult, I focused mostly on potentials:
who I would be when I grew up, and the memories I was creating.  Things happened
in real life, but I was mostly interested in them as auguries of a distant,
glittering future.  

The fantasy world was perhaps rightly more important, and I leaped into
relationships when my fantasy world intersected with someone else's.  But in
2015, entropy started to creep into my life.  Since then, every month has
started to "count frantically and seems a cudgel in a fight for happiness
against time".  (Thanks Alina for that quote!)  

The onset of this sort of reality hasn't been a surprise: I feel my parents and
education prepared me well, and I'm not caught off guard.  My friends and I seem
to be facing the challenges of life with some grace, rigor, and aplomb.  

The shift to "becoming" from "being" comes with many pleasures, as anyone who
has ever successfully played their role in the American workplace knows.  It's
not trivial to pull this sort of thing off, and that's probably why getting a
working lunch can be euphoric sometimes.

March 2nd, 2016, the day I am no longer a bro
New York is a bad dream that I am enjoying a lot

https://www.youtube.com/watch?v=V_3rcP2Duv0
I feel that it is my fate to one day be killed by a drone.

In high school, someone once told me that I was good-looking until I opened my
mouth.

Profound annoyance: "why is this my life", "this is so unnecessary"

Someone who takes a long time to explain something very straightforward, but you
appreciate it

When ambitious/powerful people complain about organization x, they always say
something like "if anyone know someone at x, please put them in touch with me".

We live in an awkward time when there are great, flexible, powerful tools for
making websites, but choosing and setting up these tools is difficult.

I have to win often, or I will probably be unsatisfied with my life.

Looking for a writer to work with: I'll carefully edit your writing if you edit
mine.  Hoping to provide and receive highly critical iterative feedback.

# Q2 Facebook Status Drafts

A couple nights ago, I couldn't sleep.  I lay awake for hours, thinking of all
the different things I've programmed in my life: all of the different languages,
paradigms, problems, and environments I've worked with.  It was a lot to think
about, and I've only been programming for about three years.

Things have already changed a lot since the summer of 2013, when Yeezus dropped
and I learned how to build web applications using NodeJS.  The world of
JavaScript development is almost unrecognizable, for one.

Here's a list of experiences:

I learned how to program for the first time in 2011.  I was living with my
parents in Buffalo, and learned HTML/CSS/JS/PHP using w3schools.com.  I was
trying to get my shit together, so I wrote down the lesson I planned to do and
then crossed it out when I finished.  This all went pretty well: within about a
month I somehow figured out how to build a "Hipster Runoff Personals" website.
Its coolest feature was a Craigslist-style email anonymizer.  (You could create
a 'personal', and someone could respond to you via an anonymized email.)  I had
to google A LOT to figure out how to do that.  This cPanel, phpMyAdmin, ftp
based method of making websites seems pretty distant now.

The next thing I remember is learning Python when I arrived at Cornell and
joined an algorithmic trading club.  I was really keen to prove myself.  I was
assigned the task of setting up a backtesting system, and eventually found a
python library to build on.  I remember having a really difficult time getting
Python set up on my windows machine, but then really enjoying the coding.   I
still feel this way about Python.  I think the fact that the language is so
elegant distracts people from how unpleasant working with Python dependencies
is.  Is virtualenv even good?  

I still love Python.  I later used Python at an summer internship (2014 in New
York), but the most notable aspect of that summer was that I learned vim and
tmux, prompted by helpful coworker.  I've continually got better with these
tools.  That was the summer I got really into the full aesthetic of programming,
the Richard Stallman stuff, beyond the world of 'web development' that once
seemed like everything.  I realized that there was sooo much to learn, and
bought an Arduino.  I finally deployed a personal website, and built a few cute
apps using Pyramid, the Python web framework I decided on.

In school I learned Java and the stuff that you typically get asked about in
programming interviews: data structures, runtime complexity, graph search
algorithms, object oriented design.  I also did a lot of pretty difficult,
complicated projects in Java, and got pretty good with it.  These projects
typically didn't focus on the language of Java itself, but other things, like
graphics, information retrieval, scalability, etc.  As a result, Java feels very
comfortable and solid to me.  After years of working in Eclipse on various
projects, I feel really comfortable with Java's standard library, and solve most
interview questions in the language of HashMaps and ArrayLists.  But I don't
really know how to build and deploy real-world applications with Java.

The experience that truly 'made me a programmer' was working at Priceline in the
summer of 2013.  My charismatic boss set me to work on a bunch of fluff projects
for my own benefit: building stuff with AWS, NodeJS, and Backbone.  I learned
really fast.  I started out with no idea how to be a programmer, and by the end
of the summer I was crushing it at hackathons and teaching stuff to my
coworkers.  NodeJS and AWS introduced me to the present paradigm of programming,
where dependencies are managed by a package manager, you run a development
server, you deploy to a server in the cloud that you can ssh into, etc.  By the
end of that summer, I felt that I could build anything.  I spent the week before
school building a course document sharing website in Node/Backbone/Mongo, and
basically finished it.  I was ready to pile on the engineering courses and
become a great programmer.

I was quite surprised by my classes.  I signed up for Cornell's functional
programming class, a pretty notorious 3000-level course taught in OCaml.  I also
signed up for a grad level database class and a deceptively difficult
information science class (where I was exposed to iPython: an intriguing tool
still), and god knows what else.  My body had also been ruined by a summer of
sitting at my laptop and I was doing everything I could to get be competitive in
rowing.  I have lots of patchy memories of 'body shutting down after practice'
in a hot, stuffy room trying to listen to lectures on implementing Red Black and
AVL trees.

But I got through that semester, quite humbled.  'Computer Science' was quite a
jump from middling web development, but I was still very into it.   In the
spring, I dialed things back, and took the 'intermediate web development' class,
which surprised me: it was cPanel PHP stuff, taught by a local wordpress guy.
It was pretty pathetic.  I barely bothered to pass, besides obsessing over our
final project, which was very interesting.  I've always been preoccupied with
building things that are useful in the 'real world', and it was exciting to work
with a small manufacturing business.  But also very difficult: these 'real
world' businesses often don't really have the money, culture or infrastructure
to support custom software.  But maybe that's our fault, as programmers?

My senior year, the main thing I learned programming-wise was C++ and graphics
programming.  I started to learn how to use Visual Studio effectively, and
learning about pointers and memory allocation was very satisfying.  I felt like
I was finally understanding some of the stuff that confused me about Python.  I
also learned about the problems associated with large codebases, where I'd have
to make changes to ten files to add another entity to our game.  I learned about
the limitations of object oriented programming when we built an Entity Component
System and Lua scripting space for the game.

In a scalability class, I was also exposed to PaaS for the first time in the
form of elastic beanstalk and elastic map reduce.  I realized how necessary such
a framework was, to avoid constant configuration difficulties.  Running
commands in the shell was starting to seem like a problem to be solved with
configuration management solutions, of which there are many.

Then I graduated.  This past year I've been on a sort of
tour-de-programming-paradigms.  During school, when I wanted to drop out, I
always promised myself that after graduation I'd allow myself an "indefinite
detox period" where I would feel free to run away from responsibilities and just
explore things, remember who I am.  I moved to New York and started picking up
freelance work, often at rates that seems inconceivable now.  (For example,
building websites from scratch for $100-$200.)  

I also did .NET development, which turned out to be important in my development
as a programmer.  I learned how to really *do* object oriented programming, and
encountered concepts like dependency injection, inversion of control, etc.  I
think I started developing a better idea of what a good software library is,
what "good code is".  I built a few experimental sites like
beststoriesonline.com using Jekyll and other static site generators, and became
intrigued by the idea of a "content as a service" as a replacement for the
current wordpress model of non-technical-end-user editable websites.

In October I started building a SaaS that I am still working on now, and think
is great.  I learned how to use paid libraries and help to  accelerate projects,
and how to manage the complexity of a complete SaaS.  I was able to componentize
front end code effectively using Angular directives.  I also really started to
fall in love with C# and Visual Studio, especially when I started fully
utilizing Visual Studio's testing framework and debugging capabilities.  I can
do a lot of stuff in Visual Studio that I have no idea of how to do anywhere
else, if it's even feasible/possible.  After playing around with Mono and .NET
Core, I'm really excited for the future of .NET.  Windows is starting to seem
like this great OS for running Linux VMs and kernels.

That summer, I started to see some 'new' ideas: microkernel architecture,
extensive configuration and pipelines by default, and an explosion of different
ways to do JavaScript.  For an example, I went to a talk on PostCSS.

At the same time, I was building a rails app with my friend.  I wasn't a huge
fan of working with Rails (a lot of stuff was a pain or just plain ugly), but it
was extremely valuable as a history lesson that explained *why* present day web
frameworks are the way they are.  I fundamentally agree with Rails' 'convention
over configuration' approach.  Ultimately, a lot of the things fundamental to
building web apps, like database migrations, environments for QA, dev, etc,
testing, an asset pipeline, form helpers for validation, MVC with view
templates,... all of these things are really just conventions that date back to
Rails (and earlier, I'm sure).  If you need to be convinced that these ideas
aren't universal, just visit the world of wordpress development (I've been doing
that a bit now, I think the finishing stretch of my
tour-de-programming-paradigms).

What am I forgetting, before I get to the stuff I'm programming now?  Making
games using GameMaker Pro when I was in 4th grade and getting in trouble for
selling them.  Developing a complicated part numbering application using
Microsoft Access.  (I wonder if that's still in use?  Chilling to think about.)
Programming these control panels for CAD cutting machines in China, mostly for
localization purposes.  Probably a lot of other stuff too.

Okay, so what about now?  I just learned React and webpack.  A lot has already
been said about the current non-sane status of the JavaScript community, so I
won't bother.  React seems good.  It's useful to me: creating well-defined,
composable components easily is a critical win.  Doing the same things in
Angular and Backbone is relatively difficult, and quite easy to fuck up in such
a way that you make life even more difficult.  I think I know JavaScript pretty
well, as a language, but I also feel like I'm continually re-learning it, even
the fundamental stuff.  I feel less enamored of Webpack: it's classic
configuration over convention misery, especially when using Babel and other
transformations.  (Is it named after the Tower of Babel?  Apt indeed!).  The
documentation is *the worst* and the system doesn't provide very good feedback
when things go wrong.  It's a pain to incorporate/shim 'legacy' (lol, more like
normal-ass) libraries that don't conform to the world of modern JavaScript.  I
feel like normal web developers are the casualties in scorched-earth framework
battles between organizations like Facebook and Google.  

But, after a bit of pain, the developer experience of React/Webpack is good, at
least within the paradigm.  I'm convinced hot reloading and pre-processors are
pretty big wins.  Still, my dad (a mechanical engineer) laughed when I showed
him the React "getting started" page.  It doesn't make any sense to someone who
isn't a "hipster" (the programming kind of hipster, which is still a meaningful
term).  Hipsters (I am one, I'm writing this in vim on a thinkpad running
linux), hipsters should be forced to spend some time using Visual Studio or
other IDE to understand that maybe everything could be a lot easier.
(Seriously: I can send someone a huge Visual Studio project and expect that they
can download Visual Studio Community, open the project, and press the green
"Run" button, and feel almost certain that it will work.  If they have a Windows
machine.)  If we're going to create these tools to make web development easier
and more efficient, perhaps we should make them a easier to set up.  Yes, it is
possible.  And, I'd like to be able to just edit files sitting on a server or my
local machine and have a dynamic web app: people seem to have forgotten that
this is even possible.  Why do you think PHP is so popular?  It's not because
it's a beautiful language.  And we need to make more things like wordpress, and
less things like Jekyll, even though Jekyll is great.

I've also started to feel the pain of maintaining live sites and managing
deployment.  I feel like continuous integration and automated monitoring (Slack
bots for example) can lessen this pain a lot.  If it's not tested, and it can't
redeployed with one click, it's broken in my mind.

As my nascent company (Computer Lab) starts taking on bigger clients, we've been
looking at different options for our "preferred language/framework".  I was
thinking that we might be a NodeJS shop, become the 'thoughtbot of NodeJS'.
But, I've worked on a few Rails projects for clients, and have experienced how
the convention over configuration nature of the framework pays off.  Working
with clients who used a PaaS and Rails made it easy to quickly into their
codebase, fix problems, add features, write tests, and get out.  It's hard to
imagine Node projects going like that, and I'm not really aware that Node is
actually being used successfully in 'real world' applications that much.  Like,
Tinder is the best example I can think of.

It looks like Computer Lab is going to be focusing on Django development,
hopefully with React in the frontend, and some sort of webpack-like developer
experience.  I'm not sure how that's going to go.  Django has good conventions,
scales well, is in Python (probably my fav language besides C#), and the Admin
interface solves a problem that I often run into during development.  There's a
lot of good examples of Django in production, and is popular in the industries
we want to serve.  I'm anxious to figure out how to consistently set up
development environments for the team and deploy to a PaaS, but I'm optimistic
that we'll figure something out.  I also wonder about the Django/React stack, is
that going to work out?  Will webpack/React play nice with Django?  

Mostly, I want to become a more patient, disciplined programmer.  I think this
is possible.  Possibly, I will also really learn 'Computer Science'.  I still
have the vaguest idea of how a computer actually works.  I'm currently working
through 'Structures and Interpretation of Computer Programs', and I'm really
looking forward to the final section, where one builds a scheme interpreter
using scheme.  I imagine that after I do that, I'll feel like I have some sort
of fundament for the work I do.  I think discipline and patience will eventually
make me enough of an expert in the frameworks I'm using that I can make more
meaningful contributions.   I want to program something that gets used a lot,
and therefore has to grow and change.  Sunlight is the best disinfectant.

wow I'm an adult holy fuck holy fuck

being high always makes me want to admit to myself that I'm nothing special
and not beautiful

big problems
take a view from a step higher
unnecessary pain

It seems impossible to get there

you haven't thought this through enough
I wish I knew some successful people

the image of Tom Cruise appears to us as the most pure normal american man
because he is an transcendent hyperreal alien being living secretly among us

I'm a small-minded man
